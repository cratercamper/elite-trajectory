using System.Collections;
using System.Collections.Generic;
using UnityEngine;

using EDTracking;


// route creation:
// - deserialize from StartRequest file (outsource to routeData)

// route visualisation
// - draw circles for wp

public class Route : MonoBehaviour {
	GameObject indicatorWaypointObject;
	Material   indicatorWaypointObjectMatBig;
	public bool isStartRequestOverrideByAuto=false;
	public TextAsset startRequest;
	public routeData rd;
	private EDRoute r;

//	[ReadOnly]
	public Vector3 displayScale = new Vector3(100.0f, -1.00f, -50.0f); // latitude is 180 (-90 to 90), longitude is 360 (-180 to 0 to 180), middle coord is height of jumps
	//public Vector3 displayScale = new Vector3(100.0f, 0.0017f, -50.0f); // latitude is 180 (-90 to 90), longitude is 360 (-180 to 0 to 180), middle coord is height of jumps
	[ReadOnly]
	public Vector3 displayShift = new Vector3(0,0,0); //automatically will be set from the first dataPoint of the first trajectory

	void setDisplayShift(EDRoute r) {
		Debug.Log("displayShift wp no:"+r.Waypoints.Count);
		if (displayShift == new Vector3(0,0,0)) { //TODO: set to start point of race?
			displayShift = new Vector3((float) -r.Waypoints[0].Location.Latitude, 0, (float) -r.Waypoints[0].Location.Longitude);
		}


		Debug.Log("displayShift:"+displayShift);
	}

	Vector3 applyDisplayShiftScale(Vector3 v) {
		return Vector3.Scale(displayScale,(displayShift + v));
	}

    void Start() {
		if (!wasAwakeCalledSoTheBugDidntManifestNow) {
			Debug.Log("ERROR: Awake was not called on route! Route:"+this);
		}
	}

    // Start is called before the first frame update
	bool wasAwakeCalledSoTheBugDidntManifestNow = false;

	void Awake() {
		if (mainControl.instance.activeRoute == null) {
			mainControl.instance.activeRoute = this;
		} else {
			this.gameObject.SetActive(false);
		}

		wasAwakeCalledSoTheBugDidntManifestNow=true;

		float metersToScale = 0.004f * 1.02f; //TODO: should depend on planet radius

		indicatorWaypointObject = (GameObject)Resources.Load("waypoint", typeof(GameObject));
//		MonoBehaviour.print("wp object:"+indicatorWaypointObject);
		indicatorWaypointObjectMatBig = (Material)Resources.Load("waypointMat_big", typeof(Material));
//		MonoBehaviour.print("wp object mat big:"+indicatorWaypointObjectMatBig);

		//EDRoute r = mainControl.getRoute();
		if (isStartRequestOverrideByAuto) {
			r = generateRouteFromTwoPoints();
		} else {
			rd = new routeData();
			r = rd.readRoute(startRequest);
		}

//		MonoBehaviour.print("ROUTE: wp cnt:"+r.Waypoints.Count+" ---- route: "+r);

		setDisplayShift(r);
		foreach (EDWaypoint wp in r.Waypoints) {

			Vector3 pos = applyDisplayShiftScale(new Vector3((float)wp.Location.Latitude, (float)wp.Location.Altitude, (float)wp.Location.Longitude));

			GameObject sphere = Instantiate(indicatorWaypointObject, pos, Quaternion.Euler(0, 0, 0));
			sphere.transform.localScale = new Vector3(metersToScale*(float)wp.Radius, metersToScale*(float)wp.Radius, metersToScale*(float)wp.Radius);

			if (wp.Radius > 500) {
				sphere.GetComponent<Renderer>().material = indicatorWaypointObjectMatBig;
			}
		}

		toggleWaypoints(false); //will be shown when F2 switches on wp times

	}


	public EDRoute getRoute() {
		return r;
	}

    EDRoute generateRouteFromTwoPoints() {
		//EDLocation loc = new EDLocation (72.475555f,17.662354f,0.0f, 2320216.0f);

		int kmPerWaypoint = 20;
		EDRoute routeAuto;
//TODO: use code when no StartRequest
		EDLocation targetLocation = new EDLocation (-9.6799920, 98.1819229999, 0.0, 1800741.375); // Hyldeptu 1 e
		EDLocation startLocation = new EDLocation (-9.6799920, 98.1819229999, 0.0, 1800741.375); // Hyldeptu 1 e

		targetLocation = new EDLocation (-48.947948, -144.128311, 0.0, 2161194.25); // Djambe ABC 1 - Crown Depot
		startLocation =  new EDLocation (-47.342247, -133.257202, 0.0, 2161194.25); // Djambe ABC 1 - Plexico Colony

		double distanceKm = 0.001 * EDLocation.DistanceBetween(targetLocation, startLocation);
		int howManyWaypoints = (int) (distanceKm / (int) kmPerWaypoint);

		List<EDWaypoint> listRouteWaypoints = new List<EDWaypoint>();
		//create waypoints - all located in target, with decreasing radii (we will track who first enters 250 km radius from target, 225 km, 200 km, ...)
		for (int i = 0; i <= howManyWaypoints; i++) {
			double distanceToTarget = ((howManyWaypoints-i)*kmPerWaypoint);//-1 ...we don't want to have first short wp & we want the last wp to be 0 km radius
			if (distanceToTarget < 0.1) {distanceToTarget = 0.1;} //last waypoint will be triggered when 100 m from target
			EDWaypoint wp = new EDWaypoint(targetLocation);
			wp.Radius = 1000.0*distanceToTarget;
			MonoBehaviour.print("Waypoint no. "+i+" dist:"+distanceToTarget+" km"); 

			listRouteWaypoints.Add(wp);
		}

		
	//	EDRoute route = new EDRoute("race3");
		routeAuto = new EDRoute("Route autogenerated", listRouteWaypoints);
		//MonoBehaviour.print("route:"+route.ToString() + " wp count:"+listRouteWaypoints.Count);
//		MonoBehaviour.print("route:"+routeAuto.ToString() + " wp count:"+listRouteWaypoints.Count);

		return routeAuto;

    }


	public void toggleWaypoints(bool show) {
		foreach (GameObject o in  GameObject.FindGameObjectsWithTag("waypoint")) {
			o.GetComponent<Renderer>().enabled = show;

		}
	}
}

